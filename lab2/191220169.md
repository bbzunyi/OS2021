# OS lab2实验报告

|  姓名  |   学号    |       邮箱        |        院系        |
| :----: | :-------: | :---------------: | :----------------: |
| 张洋彬 | 191220169 | 1016466918@qq.com | 计算机科学与技术系 |

[TOC]



## 一、实验目标

- 实现中断机制，完善IDT、TSS、中断处理程序等必要结构。
- 实现系统调用库函数`printf`
- 实现系统调用库函数`getChar`
- 实现系统调用库函数`getStr`

## 二、实验结果

printf（未输入时）打印的结果![截屏2021-04-12 上午1.11.53](/Users/mac/Desktop/截屏2021-04-12 上午1.11.53.png)

输入数据后，通过getchar和getstr函数获取值打印的结果![截屏2021-04-12 上午1.16.28](/Users/mac/Desktop/截屏2021-04-12 上午1.16.28.png)

​                 <font size=10 color=red>已完成了lab2的所有内容</font>

## 三、实验过程

### 3.1 实现bootmain函数

​	修改kMainentry、phoff和offset的值。

```c++
unsigned int elf = 0x100000;//内核的elf值

kMainEntry=(void(*)(void))(((struct ELFHeader*)elf)->entry);
phoff=((struct ELFHeader*)elf)->phoff;
offset=((struct ProgramHeader*)(elf+phoff))->off;//elf加上phoff等于程序头的偏移量
```
### 3.2 初始化

​	将函数运行所需要的所有内容进行初始化，初始化内容如下：

```c++
  initSerial();// initialize serial port
	initIdt();        	// initialize idt
	initIntr();			// iniialize 8259a
	initSeg();	 		// initialize gdt, tss
	initVga(); // initialize vga device
	initKeyTable();			// initialize keyboard device
	loadUMain(); // load user program, enter user space
```

### 3.3 实现loadUmain函数

​	在`kernel/kernel/kvm.c`中，仿造bootMain函数来实现loadUmain函数，不同的点是elf头的值以及`enterUserspace`的方式。

```c++
unsigned int elf = 0x200000;//用户代码的elf值
uint32_t uMainEntry = 0x200000;
中途跟bootmain类似
…………  
enterUserSpace(uMainEntry);
```

### 3.4 完善中断服务例程

​	在 `kernel/kernel/idt.c` 的` initIdr()` 函数中添加键断对应的门描述符、中断号 、中断处理函数 、中断特权级。

```c++
	setTrap(idt + 0x8, SEG_KCODE, (uint32_t)irqDoubleFault, DPL_KERN);
	setTrap(idt + 0xa, SEG_KCODE, (uint32_t)irqInvalidTSS, DPL_KERN);
	setTrap(idt + 0xb, SEG_KCODE, (uint32_t)irqSegNotPresent, DPL_KERN);
	setTrap(idt + 0xc, SEG_KCODE, (uint32_t)irqStackSegFault, DPL_KERN);
	setTrap(idt + 0xd, SEG_KCODE, (uint32_t)irqGProtectFault, DPL_KERN);
	setTrap(idt + 0xe, SEG_KCODE, (uint32_t)irqPageFault, DPL_KERN);
	setTrap(idt + 0x11, SEG_KCODE, (uint32_t)irqAlignCheck, DPL_KERN);
	setTrap(idt + 0x1e, SEG_KCODE, (uint32_t)irqSecException, DPL_KERN);
	setIntr(idt + 0x21, SEG_KCODE, (uint32_t)irqKeyboard, DPL_KERN);
	setIntr(idt + 0x80, SEG_KCODE, (uint32_t)irqSyscall, DPL_USER);//用户级别
```

### 3.5 实现`syscallPrint`（`printf`对应的处理例程）

​	在` kernel/kernel/irqHandle.c `中完善 `syscallPrint() `函数，思路如下：

```c++
asm volatile("movb %%es:(%1), %0":"=r"(character):"r"(str+i));//把str[i]读到character里
if(character=='\n'){
  displayCol=0;
  displayRow++;
  if(displayRow=25)//已经满了，超出边界
  	行号-1，调用scrollScreen函数往上滚一行
}
else{
  data = character | (0x0c<<8);
	pos =(80*displayRow + displayCol)*2;
	asm volatile("movw %0,(%1)"::"r"(data),"r"(pos+0xb8000));//将charater打印出来
  displayCol=(displayCol+1)%80;
  if(displayCol==0){
    ……//实现如上
  }
}
```

### 3.6 实现`printf`的格式化输出

​	在`syscall.c`函数里面已经实现了`dec2str`，`str2str`，`hex2str`函数,在printf里面需调用他们实现中断，以decimal来进行说明，代码如下：

```c++
case 'd':
					index++;
					decimal = *(int*)(paraList + 4 * index);
					count = dec2Str(decimal, buffer,(uint32_t) MAX_BUFFER_SIZE, count);
					break;
```

- 外层是一个while循环，当遇到 `format[i] = '%' `时表示此处需要格式化输出
- `%d` 表示十进制数，类型为 `int` ，现将index++(目前是%d）；通过 `*(int*)(paraList + sizeof(void*) * index)` 取到参数列表中的第`index`个参数。并通过强制转换得到`int`型数据。
- 利用框架代码提供的 `dec2Str() `函数将十进制整数转换为字符串并修正 `count`

### 3.7 实现`KeyboardHandle()`函数

​	`keyboardhandle`主要分三种情况，先使用getchar(code)得到输入字符的ascii码，然后思路如下：

```c++
if(退格符)：
  displayCol--，然后用0去覆盖已经打印的字符
else if(回车符)：
  和systemPrint实现类似，把回车符存入keyBuffer
else if(正常字符)：
  if(code==0x2a||code == 0x36||code == 0x38||code == 0x3a||code == 0x1d){
			keyBuffer[bufferHead]=code;
		}
		else{
		if(keyBuffer[bufferHead]==0x2a||keyBuffer[bufferHead]==0x36){
			keyBuffer[bufferHead]=0;
			character-=0x20;
		}//shift问题，先按shift，再按b，会被转化成B
  注意大小写问题，将这个字符打印出来，然后和systemPrint类似
```
​	可以实现大写字母的打印和转换
![截屏2021-04-12 上午11.24.32](/Users/mac/Library/Application Support/typora-user-images/截屏2021-04-12 上午11.24.32.png)

### 3.8 实现`getchar()`函数

​	因为在keyBuffer里存储了输入的字符，所以说读取keybuffer即可实现，具体代码如下：

```c++
	bufferHead = 0, bufferTail = 0;//init
	keyBuffer[0]=0;
	while(keyBuffer[bufferTail]!='\n')//遇到回车结束
		enableInterrupt();//允许中断
	int charactor = keyBuffer[1];//读取输入的第一个字符
	tf->eax = charactor;
	disableInterrupt();//关闭中断
```

​	getchar()自身代码如下：

```c++
char character;
character = syscall(SYS_READ, STD_IN,(uint32_t)&character, 1, 0, 0);
return character;
```



### 3.9 实现getStr()函数
 	因为在keyBuffer里存储了输入的字符，所以说读取keybuffer即可实现，需注意因为要用到用户空间，所以需要进入用户态（模仿printf），具体代码如下：

```c++
	bufferHead = 0;
	bufferTail = 0;
	keyBuffer[bufferHead] = 0;
	int sel =  USEL(SEG_UDATA);
	asm volatile("movw %0, %%es"::"m"(sel));
	char charactor = 0;
	char* str = (char*)tf->edx;
	while (keyBuffer[bufferTail] != '\n')
		 enableInterrupt();
		
	for (int i = 0;i < 100;i++){
		charactor = (char)(keyBuffer[i+1]);
		if(charactor=='\n')break;//遇到回车结束
		asm volatile("movb %0, %%es:(%1)"::"r"(charactor),"r"(str+i));
	}
	disableInterrupt();
```

​	getStr()自身代码如下：

```c++
syscall(SYS_READ, STD_STR, (uint32_t)str, size, 0, 0);
return;
```



## 四、实验介绍中的问题

**问题：**IA-32提供了4个特权级, 但TSS中只有3个堆栈位置信息, 分别⽤于ring0, ring1, ring2的堆栈切

换。为什么TSS中没有ring3的堆栈信息?

**回答：**TSS是用来进行任务（进程）切换的，只有低特权级到高特权级切换时，新堆栈的信息才会从TSS

中取得，ring3是最低特权级，故TSS中没有ring3的堆栈信息。



## 五、关于本次实验的感想

​	本次实验最大的问题就是不知道怎么bebug，用assert（0）也不会出现什么反应，我在irqHandle里遇到了一些问题，tf->irq是-1的时候我加了一个assert（0），但是此时应该不做任何操作即可。实验难度较上次有提升，但是框架代码给出的信息还蛮多的，整体实现比较有趣（感觉像在做数电实验一样），实验做完后也基本了解了printf和getchar以及getstr函数的实现，感觉收获还蛮多的。
# 操作系统笔记

## 一、操作系统概论

现代计算机系统是由硬件和软件相互交织形成的集合体，构成一个解决计算问题的工具。

- ==硬件==是软件运行的***物质基础***
- ==软件==能够充分地发挥***硬件潜能并扩充其功能，***完成各种任务

两者互相促进，相辅相成，缺一不可

- 操作系统是一个程序，***充当计算机用户与计算机硬件之间的媒介***，目的是为用户提供一个环境，使用户能够以便利和有效的方式运行程序。(扩展机器-抽象与虚拟)

- 操作系统是管理系统资源、控制程序执行、改善人机界面、提供各种服务，合理组织计算机工作流程和为用户有效使用计算机提供良好运行环境的一种系统软件。（资源管理-保护与复用）

##### 并发性

​	指两个或两个以上的事件或活动在同一时间间隔内发生

- 提高资源利用率
- 增加管理复杂度
- 支持并发的操作系统，被称为多任务系统



##### 并行性

​	指两个或两个以上事件或活动在同一时刻发生

- 并行是并发的特例，限制更加严格



##### 异步性

- 任务的执行时间、推进速度等不定
- 事件发生的不可预期，如各种中断的发生



##### 虚拟性

  可以把物理上的一个实体变为逻辑上的多个对应物，或把物理上的多个实体变成逻辑上的一个对应物的技术。

##### 多道批处理的特点

- 提高了效率，但对于每一道程序来说，延长了计算时间
- 多道程序设计技术提高资源利用率和系统吞吐率是以==牺牲用户的响应时间为代价的==

##### 批处理操作系统

​	批量化处理作业方式的操作系统称为批处理操作系统。

***特点***：

- 用户脱机工作
- 成批处理作业
- 多道程序运行
- 作业周转时间长

##### 分时操作系统

​	允许多个联机用户同时使用一台计算机系统进行计算的操作系统称为分时操作系统。

***特点***：

- 同时性，多个用户同时
- 独立性，每个用户相对独立
- 及时性，快速响应用户请求
- 交互性，用户联机工作

##### 实时系统

​	必须在一个实现定义好的事件限制内，对外部或内部的事件进行响应和处理。

按满足条件的不同分为:

- 硬实时系统
- 软实时系统

典型的实时系统：

- 过程控制
- 信息查询
- 事务处理



##### 操作系统结构-内核

​	内核态和用户态的区别在于对==硬件的访问权限==不同:内核态下的程序---操作系统拥有对硬件 的完全访问权限，能够执行机器支持的所有指令，例如影响机器控制和 I/O 操作的指令，具有绝对的特权;而用户态下的程序仅能使用机器指令的一个子集，不能执行属于内核态的特权指令。在处理器具备内核态和用户态两种工作模式的前提下设计操作系统，能够通过硬件机制保障运行在内核态下的操作系统的主导地位，保证系统的安全性。这两种工作模式的区分赋予了操作系统特权并提供保护，使得用户程序对硬件的访问受到操作系统的限制和管理:用户程序只能在用户空间操纵用户数据，调用用户程序中的过程而不能直接访问内核数据或者直接调用服务例程



>***自陷指令***是为了进行系统调用而引起处理器中断的机器指令，这是一条非特权指令，在用户 态下执行时会将 CPU 的工作模式切换到内核态，使得操作系统的相应服务例程得以执行 应用程序执行系统调用，产生中断转向内核态，进入陷阱处理程序，它将按功能号来查询入 口地址表，并转至对应服务例程执行;完成后退出中断，返回应用程序断点继续运行



## 二、处理器管理

​	处理器管理是操作系统的重要组成部分，负责管理、调度和分派计算机系统的重要资源---==处理器==，并控制程序执行。



##### 程序状态字（PSW）

​	Intel x86机器中，PSW由***标志寄存器EFLAGS和指令指针寄存器EIP***组成，均为32位。EFLAGS低16位称为FLAGS，可以做一个单元来处理。

​	每个程序都有一个与其执行相关的PSW，而每个处理器均设置一组相关寄存器用于存储PSW信息。

##### 中断

​	中断是指在程序执行过程中遇到急需处理的事件时，暂时中止现行程序在CPU上的运行，转而执行相应的事件处理程序，待处理完成后再返回断点或调度其他程序执行的过程。

由硬件发出或产生的中断叫做硬中断

- 外中断

  外中断又称中断或异步中断，是指来自处理器之外的中断信号，包括时钟中断、键盘中断、它机中断和外部设备中断。

> 外中断分为***可屏蔽中断***和***不可屏蔽中断***，每个中断有不同的中断优先级，表示事件的紧急程度，在处理高一级中断时，往往会部分或全部屏蔽低级中断。

- 内中断

  内中断又称==异常==或同步中断，是来自处理器内部的中断信号。

***内中断不能被屏蔽，一旦出现应立即予以响应并进行处理***

中断响应的过程：

1、发现中断源

​	在中断未被屏蔽的前提下，硬件发现中断/异常事件，并由CPU响应中断/异常请求。当发现多个中断源时，将根据预定的中断优先级先后响应中断。

2、保护现场

​	暂停当前程序运行，硬件将中断点的现场信息（PSW）保存至核心栈中，以便结束后返回原程序继续运行

3、转向中断/异常事件处理程序执行

​	此时已经从用户态转换至内核态，中断/异常处理程序开始工作。

4、恢复现场

​	当中断处理结束后，恢复原运行程序的PSW，重新返回中断点以便执行后续指令。



> 异常处理过程中是可以阻塞的，中断是不可以阻塞的
>
> 中断允许发生嵌套，但异常大多为一重

##### 中断屏蔽

中断屏蔽可分为；

- 禁止CPU响应中断

  硬件产生中断，CPU暂时不予响应，等待直到中断开放后被屏蔽的中断才能被响应并获得处理。如处理一个I/O中断，或内核处理临界区必须连续执行防止被意外事件打断。

- 禁止中断产生

  可引起中断的事件发生时，硬件不允许提出中断请求也不通知处理器。当一些异常发生时，CPU可正常运行，不理睬这些事件

##### 多重中断/嵌套中断：

- 串行处理：和上面的禁止cpu响应中断一样
- 嵌套处理：不屏蔽高优先级的中断，一般最多嵌套三层
- 即时处理：立即响应中断



##### LINUX中断机制：

0～31的向量对应异常和非屏蔽中断

32～47的向量对应屏蔽中断

48～255向量分配给软中断



中断请求：发生中断时申请一个IRQ号



中断描述符表：（IDT）

​	此表包含256个表项，每个中断/异常都对应一个表项，每个表项称为一个门描述符



***中断处理程序的执行***

1、中断信号由外部设备发送到中断控制器，根据IRQ号转换成中断向量号送给CPU

2、CPU根据中断向量号去查IDT表，跳到中断处理程序入口地址，中断向量号入栈，利用宏SAVE_ALL保护寄存器核心栈，然后调用do_irq函数

3、do_irq函数对所接受的中断进行应答，禁止该中断线，在关中断的条件下，do_irq函数用Handle_IRQ_event函数执行注册到中断线上的所有中断服务例程

4、返回至内核ret_from_sys_call代码来完成一组标准任务，如有软中断则调用do_softiq函数处理软中断，有信号就调用do_signal函数处理信号，最后调转到ret_from_intr退出中断，恢复现场



上半部分（top half）和下半部分（bottom half），上半部分收到中断立刻开始工作，在关中断状态下，只做严格限时且与硬件相关的任务，通知下半部分做剩余工作。

下半部分是延时处理的，一般拿来处理比较耗时的工作，是可以被打断的。



##### 进程

进程的定义：

- 进程是程序的一次动态执行。
- 进程是一个程序及其数据在处理机上顺序执行时所发生的活动。
- 进程是具有独立功能的程序在其数据集合上运行的过程，他是系统调度和资源分配的一个独立单位。



##### 三态模型

- 运行态
- 就绪态：具有运行条件
- 等待态：阻塞态或睡眠态，进程不具有运行条件，正在等待某个事件完成的状态



七态模型

- 新建态：还未加入就绪队列
- 终止态：刚好结束，还未回收资源或删除

- 挂起态：把进程内容暂时移除内存，存放在磁盘中（挂起等待，挂起就绪）



某时刻进程的内容及其状态集合称为进程映像，包括以下要素：

（1）进程控制块。

（2）进程程序块。

（3）进程核心栈。

（4）进程数据块。



- 用户级上下文
- 寄存器上下文
- 系统级上下文

##### 进程控制块

 每个进程有且只有一个进程控制块（PCB），或称进程描述符

- 标识信息

  进程ID、进程组标识ID、用户进程名、用户组名。

- 现场信息
  - 通用寄存器内容
  - 控制寄存器内容
  - 栈指针
  - 程序状态字

- 控制信息：用于管理和调度进程

  - 进程调度的相关信息
    - 进程状态
    - 等待事件
    - 等待原因
    - 进程优先级
    - 队列指针

  - 进程组成信息
  - 进程间的族系信息
  - 进程通信信息
  - 进程段页表、进程映像在外存中的地址
  - 进程特权信息
  - 资源清单
  - 文件传输与I/O信息



​	把==同一状态的所有进程的PCB==链接在一起的数据结构称为进程队列，简称队列

队列组织方式

- 链接方式
- 索引方式

<font color=red>进程切换必定在内核态而非用户态发生</font>

处理器状态切换不同于进程上下文切换，在大多数情况下，状态转换不一定引起上下文切换



进程创建

进程撤销

进程阻塞和唤醒

进程挂起和激活



##### 线程

进程作为系统资源分配和保护的独立单位，无须频繁地切换

线程作为系统调度和分配的基本单位，会被频繁地调度和切换。

###### 线程的优点

1、快速线程切换。同一进程中多线程切换只需改变堆栈和寄存器，地址空间不变

2、通信易于实现。自动共享进程的内存和文件，线程可自由访问全局数据，实现数据共享十分方便，线程通信简单不必通过内核

3、减少管理开销。线程创建和撤销工作比进程少很多，并且无需再分配存储空间和各种资源

4、并发程度提高。多线程适宜并行工作，能充分发挥处理器与设备的并行工作能力，使多核和多处理器系统的效能发挥得更好



##### 剥夺式与非剥夺式

​	剥夺式策略比非剥夺式的策略开销要大，主要是调度程序自身开销及内存和磁盘对换程序与数据的开销。



##### <font color=red>作业调度和低级调度算法</font>

1、先来先服务算法 FCFS

​	按到达的先后顺序

2、最短作业优先算法 SJF

​	按服务时间的长短来服务

平均带权作业周转时间：$\frac{作业周转时间}{所需CPU时间}$的平均值

3、最短剩余时间优先算法 SRTF

​	剥夺式调度算法，当出现剩余时间比当前小的时候的进程，切换

4、最高响应比算法 HRRF

响应比=作业周转时间/作业处理时间=（作业处理时间+作业等待时间）/作业处理时间

越大越先处理

HRRF算法性能介于SJF算法和FCFS算法之间

5、优先级调度算法

​	剥夺式/非剥夺式

6、轮转调度算法（RR算法）

​	时间片用完，切换下一进程，当前进程到尾部

7、多级反馈队列算法（MLFQ）

队列之间有优先级，同一队列中的进程/线程按FCFS原则排队



## 三、同步、通信和死锁

### 并发进程概述

##### 	顺序程序设计

​	将一个程序设计成一个顺序执行的程序模块，不同的程序也是顺序执行的

优点：程序编制、调试方便

缺点：计算机系统效率较低

### 临界区管理

临界区：

​	并发进程中与共享变量有关的程序段，称为临界区

临界资源：

​	共享变量代表的资源，称为临界资源

临界区管理：

​	保证一个进程在临界区执行时，不让另一个进程进入相关的临界区



***临界区调度的规则***

- 一次至多一个进程能够进入临界区
- 不能让一个进程无限地留在临界区
- 不能强迫一个进程无限等待进入临界区
- “无空等待、有空让进、择一而入、算法可行”

Dekker算法

​	采用变量turn来指示该由哪个进程进入临界区

Peterson算法



### 信号量与PV操作

##### 生产者消费者问题

​	由于生产者和消费者进程执行速度的不一致将导致：

- 缓冲区计数器出错
- 错过等待唤醒

  该解决方案使用了三个信号量：一个称为full，用来记录充满缓冲槽数目，一个称为empty，记录空的缓冲槽总数；一个称为mutex，用来确保生产者和消费者不会同时访问缓冲区。full的初值为0，empty的初值为缓冲区中槽的数目，mutex的初值为1。供两个或多个进程使用的信号量，其初值为1，保证同时只有一个进程可以进入临界区，称作二元信号量。如果每个进程在进入临界区前都执行down操作，并在刚刚退出时执行一个up操作，就能够实现互斥。

```c

#define N 100
typedef int semaphore;
semaphore mutex = 1;
semaphore empty = N;
semaphore full = 0;
void producer(void)
{
	int item;
	while(TRUE)
	{
		item = produce_item();
		down(&empty);				//空槽数目减1，相当于P(empty)
		down(&mutex);				//进入临界区，相当于P(mutex)
		insert_item(item);			//将新数据放到缓冲区中
		up(&mutex);				//离开临界区，相当于V(mutex)
		up(&full);				//满槽数目加1，相当于V(full)
	}
}
void consumer(void)
{
	int item;
	while(TRUE)
	{
		down(&full);				//将满槽数目减1，相当于P(full)
		down(&mutex);				//进入临界区，相当于P(mutex)
		item = remove_item();	   		 //从缓冲区中取出数据
		up(&mutex);				//离开临界区，相当于V(mutex)		
		up(&empty);				//将空槽数目加1 ，相当于V(empty)
		consume_item(item);			//处理取出的数据项
	}
}

```



P操作：

​	将信号量value-1，如果结果小于0，执行P操作的进程被阻塞，排入与s信号量有关的list所指队列中

V操作：

​	将信号量value值加1，若结果不大于0，执行V操作的进程从信号量s有关的list所指队列中释放一个进程。

信号量s的value代表实际还可以使用的物理资源数量。P操意味着请求一个资源（可能被阻塞），V操作意味着释放一个资源（唤醒被阻塞的进程）

##### 哲学家就餐问题：

![截屏2021-06-24 下午6.10.56](/Users/mac/Library/Application Support/typora-user-images/截屏2021-06-24 下午6.10.56.png)

##### 读者写者问题



### ![截屏2021-06-24 下午7.45.18](/Users/mac/Library/Application Support/typora-user-images/截屏2021-06-24 下午7.45.18.png)

读者写者公平

![截屏2021-06-24 下午7.45.59](/Users/mac/Library/Application Support/typora-user-images/截屏2021-06-24 下午7.45.59.png)

##### 理发师问题

![截屏2021-06-24 下午9.54.53](/Users/mac/Library/Application Support/typora-user-images/截屏2021-06-24 下午9.54.53.png)

### 管程

​	把分散在各进程中的临界区集中在一起管理，并把系统中的共享资源用数据结构抽象地表示出来

- 条件变量：
  - 只有在管程中才能被访问，进程可以在条件变量上等待或被唤醒

![截屏2021-06-24 下午11.06.33](/Users/mac/Library/Application Support/typora-user-images/截屏2021-06-24 下午11.06.33.png)

wait（）原语可延迟进程的执行，signal()原语使得被延迟进程中的某个进程恢复执行

***Hoare***采用第一种方法（进程P等待直至进程Q退出管程，或者进程Q等待另一个条件）



进程进入管程时执行P（muteX），退出管程时执行V（muteX）

```c
P(IM.mutex);
···
if(IM.next_count>0){
  IM.next_count--;
  V(IM.next);
}
else
  V.(mutex)
  
```

分为两种等待：

- 通过wait在x_sem上进行等待
- 通过signal在next变量上进行等待z

### 进程通信

并发进程之间的交互必须满足两个基本需求：同步和通信

> 同步缺乏传递数据的能力

进程之间互相交换信息的工作称为进程通信（IPC），线程通信基本是由进程通信演变而来的

通信方式有很多种：信号通信机制，管道通信机制，消息传递通信机制，信号量通信机制，共享内存通信机制



信号通信机制

​	又称软中断，与中断不同的点是信号完全由软件来实现，发送一个特定的信号来通知进程某个异常事件的发生。信号可以是内核发送给进程，也可以是进程发送给另一个进程。



管道通信机制

​	又称共享文件通信机制，管道允许进程按先进先出的方式传送数据，也能使进程同步执行操作![截屏2021-06-25 上午11.11.31](/Users/mac/Library/Application Support/typora-user-images/截屏2021-06-25 上午11.11.31.png)

在linux中，管道是利用文件系统的file结构和inode结点来实现的，当创建管道时，系统打开文件表中建立管道文件的两个file结构用于控制管道的读写操作，两个file结构指向同一个inode，inode指向磁盘上的物理页面。内存调用inode创建管道后，返回句柄file[0]&file[1]，读者进程通过file[0]从管道取出数据，写者进程通过file[1]向管道写入数据

***共享内存通信机制***

​	类似于临界区

***消息通信机制***

​	信号的高级版

### 死锁

死锁的产生

​	当一个进程需要独占多个资源，而操作系统允许多个进程并发执行共享系统资源时，可能出现进程永远处于等待状态的现象（死锁）

死锁产生的因素

- 系统拥有资源的数量
- 资源分配策略
- 进程对资源的需求
- 并发进程的推进顺序

静态分配策略，一开始就分配所有需要的资源



#### 银行家算法

- 知道每个用户所要求的最大资金量
- 银行满足了用户之后，用户要归还所申请的资源

Pi--->Ri,进程pi申请资源Ri，Ri->Pi,资源Ri分配给Pi

- 资源分配图中无环，则没有发生死锁
- 如果资源分配图中有环路，且每个资源类中仅有一个资源，则系统中发生死锁

![截屏2021-06-25 下午1.09.31](/Users/mac/Desktop/截屏2021-06-25 下午1.09.31.png)

​	对于抢占式调度并且存在两个不同优先级进程同时访问临界区时，Peterson 算法是不能解决 互斥的。原因在下一道题目之中已经给出，此时可能会发生优先级反转的现象，即:当低优 先级进程在运行并同时也占有了临界区资源时，高优先级进程抢占 CPU，但临界区资源被低 优先级进程占有，所以高优先级进程将会陷入忙等中，但基于抢占式调度，高优先级进程未 结束前，低优先级进程永远不会恢复访问并且一直占有临界区资源，变相造成死锁。Peterson 算法对于抢占式调度中用来相同优先级的进程间是可以的。



##### 死锁检测算法

和银行家算法类似，只要满足需求就可，不用满足最大需求

## 四、文件管理

### 文件

​	文件与管理信息资源的管理程序的集合称为文件系统

> 文件系统是操作系统中负责存取和管理信息的模块，他用统一的方式管理用户和系统信息的存储、检索、更新、共享和保护，并为用户提供一整套方便有效的文件使用和操作方法

文件系统的功能：

- 文件的按名存取（基本功能）
- 实现目录的建立和维护
- 实现逻辑文件到物理文件的转换
- 文件存储空间的分配和管理
- 数据保密、保护和共享
- 提供一组用户使用的操作



文件名字通常由文件名和扩展名组成，中间用.来分隔，前者标识文件内容、后者标识文件特性



文件存取方式：

- 顺序存取
- 直接存取（非顺序式存储）
- 索引存取



### 文件目录

​	文件控制块（FCB），包含了全部文件属性，一个文件由两部分组成：FCB和文件体（文件信息）

> 每当创建一个文件时，系统就要为其创建一个FCB，方便地实现文件的按名存取；每当存取文件时，先找到FCB，再找到文件信息盘块号、首块物理位置或索引表就能存取文件信息

FCB汇集和组织在一起形成文件目录，文件目录包括很多目录项，目录项有两种，分别用于描述子目录和目录文件。全部由目录项所构成的文件称为目录文件，并保存在外存上，查找文件时掉入内存。目录文件永远不为空，至少包括两个目录项：当前目录项‘.’和父目录项‘..'

FCB的文件名和其他信息分离出来

基本目录项：文件名和inode号

活动inode表：放在内存中，不用频繁地去磁盘上调。当用户关闭文件时，活动inode的内容写到磁盘inode中，再释放活动inode以供他用。



硬链接：把文件名和自身inode链接起来，称为硬链接

软链接：又称符号链接，只包含被链接文件的路径名，不指向inode

### 文件的组织与数据存储

### 文件系统的其他功能

bit map：每个位置代表是否被使用

free list：将还未使用的块的地址使用链表链接起来



把inode加入活动inode表，把用这个inode号去磁盘调他的目录文件

## 五、存储管理

访问外存的页面：

1、将外存页面调入内存（找到合适的页框）

2、访问内存

### 反置页表

​	一个表项包括进程页号，页号所属进程的标识符和哈希链指针。有可能多个页号映射得到相同的HASH值，用哈希链来解决这种冲突。

​	IPT能减少页表对内存的占用，==然而，IPT仅包含掉入内存的页面==，不包括未调入的页面，仍需要为进程创建传统页表，不过此页表不再放在内存中，而是放在磁盘上。

##### 可变分区存储管理

- 最先适应分配算法 从0开始找合适的空闲区
- 下次适应算法，从上次结束的位置开始找
- 最优适应算法，找到能满足的最小的空闲区
- 最坏适应算法，找一个最大的空闲区
- 快速适应：相当于索引



##### 全局页面替换策略 

- 最佳页面替换算法（OPT），淘汰以后不再访问的页或者距现在最长时间后才访问的页。

- 先进先出页面替换算法（FIFO）

- 最近最少使用页面替换算法（LRU）

  - 引用位法（R）

    周期性将引用位置0，访问一个页面是置1，每次淘汰在引用位为0的里面淘汰

- 第二次机会页面替换算法（SCR）

  引用位为1置0放队尾，为0直接淘汰

- 时钟页面替换算法（clock）

  找引用位为0的

  改进后的：

  1、先扫描一遍，找r=0 m=0的页面作为淘汰页

  2、找r=0.m=1的页面，过程中并把r置0

  3、回到1 2



##### 局部最佳页面替换算法

（1）MIN（滑动窗口r）

​	在（t，t+r）中不被引用，则移出窗口

（2）WS（工作集$\Delta$）

​	在（t-$\Delta$，t）中不被引用则移出窗口





## 六、设备管理

直接存储器存储DMA方式中，内存和设备之间有一条通路成块地传送数据



#### 1、I/O硬件原理

##### 1.1、I/O系统

- 通常把I/O设备及其接口线路、控制部件、通道和管理软件称为I/O系统，把计算机的内存和设备介质之间的信息传送操作称为I/O操作
- 输入型设备、输出型设备和存储型设备（又分为顺序存储和随机存储）
- 字符设备和块设备

##### 1.2、I/O控制方式

主要区别在于CPU和设备的并行工作的方式和程度不同

- 轮询方式

  - 查询指令，查询设备是否就绪
  - 读写指令，如果设备就绪，开始读写
  - 转移指令，如果设备未就绪，转移到查询指令

- 中断方式

  - 进程发出启动I/O指令，CPU加载控制信息到设备控制器的寄存器，进程继续执行或者等待I/O操作完成
  - 设备控制器检查状态寄存器内容，根据指令要求完成I/O操作（将数据放到I/O缓冲寄存器中），传输完成发送I/O中断请求
  - CPU响应中断，转到中断处理程序
  - 中断处理程序（也可以由设备驱动程序完成）执行读写到内存的操作，完成后退出
  - 进程调度程序适当的时候恢复进程运行

- DMA（直接存储器存取）方式（设备与内存直接交换数据无需占用CPU）

  内存和设备之间有一条数据通路成块地传送数据，无需CPU敢于，实际数据传输操作由DMA直接完成，为了实现直接存储器存取操作，需要以下逻辑部件：

  - 内存地址寄存器：存放内存中需要交换数据的地址，传输前放入首地址，每次交换数据都加一
  - 字计数器：记录传送数据的**总字数**，每次传送一个字减一
  - 数据缓冲寄存器或数据缓冲区：暂存每次传送的数据
  - 设备地址寄存器：存放I/O信息的地址，如磁盘的柱面号、磁头号、扇区号
  - 中断机制和控制逻辑：用于向CPU提出I/O请求以及保存CPU发来的I/O命令，DMA中也要设置移位寄存器、字节计数器

- 通道方式

  - 通道又称I/O处理器，能完成内存和设备之间的信息传送，与CPU并行地执行操作

  - 一个CPU连接若干通道，一个通道连接若干控制器，一个控制器连接若干设备

##### 1.3、设备控制器

设备控制器是CPU和设备之间的接口，主要功能：

- 接收和识别CPU或通道发来的命令
- 实现数据交换
- 发现和记录设备及自身的状态信息，供CPU处理
- 设备地址识别



#### 2、I/O软件原理

操作系统把I/O软件一次组织成4个层次：I/O中断处理程序，I/O设备驱动程序，独立于设备的I/O软件和用户空间的I/O软件

- I/O中断处理程序，通常是设备驱动程序的组成部分之一，位于操作系统底层，是与硬件设备密切相关的软件
- I/O设备驱动程序：
  - 设备初始化
  - 执行设备驱动例程
  - 调用和执行中断处理程序
- 独立于设备的I/O软件：基本功能是执行适用于所有设备的常用I/O功能，并向用户层软件提供一致性接口
  - 设备命名和设备包含（所有的设备都视为文件，不过设备的inode中存着内核设备驱动程序的指针）
  - 提供与设备无关的块尺寸
  - 缓冲技术
  - 设备和状态跟踪
  - 错误处理和报
- 用户空间的I/O函数
  - 库函数
  - SPOOLing软件
- 一条读操作的执行过程：
  - 应用进程调用库函数读已打开文件
  - 独立于设备的I/O软件检查参数是否正确、要读的数据是否在高速缓存中等，如果不在，则将设备名转换为物理名，将进程阻塞，等待I/O操作完成
  - 内核启动设备驱动程序，向设备控制器发送信号，开始读入缓冲区
  - 传输完成后，硬件产生I/O中断，系统调用I/O中断处理程序，如果失败则想设备驱动程序发送请求重新读，成功则直接读入内存

#### 3、缓冲技术

- 单缓冲：在内存的系统去开设一个缓冲区
- 双缓冲：两块缓冲区交替使用，也就是省了从缓冲区到内存的时间
- 多缓冲



#### 4、驱动调度技术

- 目的：按最佳次序执行要求访问磁盘的诸多请求

##### 4.1、存储设备的物理结构

- 结构：许多盘面用来存储数据，每个盘面有一个读写头，一圈是一个磁道，通一个位置的磁道组成柱面，磁道的一段成为扇区
- 要访问磁盘，必须给出三个数据：柱面号、磁头号、扇区号
- 磁盘机根据柱面号控制移动臂横向机械移动，找到相应柱面，时间成为查找时间（很慢）
- 选择磁头，然后等待被访问的扇区移动到这个读写磁头下，存取信息，称为搜索延迟

##### 4.2、循环排序和驱动调度算法（不同物理块的的寻道时间不同）

- 读出一组数据块的时间：找到第一个数据块的时间+读出并处理所有数据块的时间
- 旋转延迟：旋转到对应扇区需要的时间，注意，磁盘旋转是不会停的，所以在读完数据处理的时候，磁头还是在转
- 寻道延迟：移动机械臂的时间，应当先读同一柱面的数据，移动臂调度算法：
  - 先来先服务（FCFS）：磁盘臂随机移动，不考虑相对次序，寻道性能差
  - 最短查找时间算法：总是先执行查找时间最短的请求（性能好，但是会造成饥饿）
  - 扫描算法：移动臂每次沿一个方向移动，扫描过所有最近的I/O请求便进行处理，再向相反的方向移动过来（即使一个方向没有请求也要移动）
  - 分步扫描算法：按照FIFS的方式划分子队列，每个队列N个I/O请求，先处理前面的子序列，每个子序列中采用扫描算法，这样可以避免“磁臂粘性”，N很大时接近扫描算法，N=1时就是FIFS
  - 电梯调度算法：又称LOOK算法，无访问请求是，移动臂停止不动，有访问请求时，移动臂按电梯规律移动。其实就是扫描算法不扫描到头的实现
  - 循环扫描算法：移动到头的时候不是返回，而是从另一头开始扫描

#### 5、提高磁盘I/O速度的方法

- 提前读
- 延迟写
- 虚拟盘



##### 二级页表的优势

页表不需要连续存放，只需要部分放在内存中，减少内存的使用